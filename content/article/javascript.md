### 変数の定義
let 変数名 = "";

### 定数の定義
const 定数名 = "";

### テンプレートリテラル
文字列の連結方法のひとつ<br>
1. 文字列全体をバッククォート(`)で囲む
2. 文字列に埋め込む定数や変数は${定数/変数}とする

### 比較演算子
データ型まで同じか比較するときは「===」「!==」で比較する

### switch文
ある値によって処理を分岐する<br>
breakを入れ忘れると他の条件の処理も実行されてしまうため注意！
```
switch(条件となる定数、変数){
    case 値:
        処理;
        break;
    default:
        どのcaseも当てはまらなかった場合の処理;
        break;
}
```

### 配列
const 配列名 = ["aaa","bbb"];
- [constと配列](https://teratail.com/questions/121164)
> const 宣言は、値への読み取り専用の参照を作ります。その値が不変ということではなく、その変数識別子が再代入できないというだけです。たとえば、定数がオブジェクトのコンテンツの場合、オブジェクトのコンテンツ(例 その引数)自体は変更可能です。<br>

*→配列の中身（箱に入れるもの）は変更可能、配列自体（箱自体）は変更不可というイメージ？*

- 配列名.push() : 配列の最後に新しい要素を追加
- 配列名.forEach((配列名の単数形) => {処理}) : 配列のすべての要素に繰り返し同じ処理を行う
  - forEachの中身がアロー関数になっている
  - 引数に入っている関数のことをコールバック関数と呼ぶ
- 配列名.find((配列名の単数形) => {return 条件}) : 配列の中から条件に一致する最初の要素１つを取り出す
- 配列名.filter((配列名の単数形) => {return 条件}) : 配列の中から条件に一致する要素全てを取り出し、新しい配列を作成する
- 配列名.map((配列名の単数形) => {return 処理}) : 配列のすべての要素に処理を行い、新しい配列を作成する

### コールバック関数
関数の引数として渡される関数
#### 意義
- 処理を分割でき、汎用性が高まる
  - [コールバック関数のメリット](https://maaengineerhouse.com/archives/824)
- 代入する名前を固定して、様々な挨拶をしたいとき、名前を定義するのが1箇所（コールバック関数の呼び出し元関数）で済む
  - [コールバック関数のメリット２](https://qiita.com/mitsumizo/items/ecc82c166d96dc5fe95b)

### オブジェクト
const 定数名 = {プロパティ名1:値1, プロパティ名2:値2};
- 定数名(オブジェクト).プロパティ名で値を取り出し可能

### undefined
配列の存在しないインデックス番号の要素や、オブジェクトの存在しないプロパティの要素を取得しようとした場合に出力される値

### アロー関数
```
const 関数名 = (引数) =>{
    処理
}
```

### スコープ
定数や変数を使用できる範囲
- 関数内で定義したものはその関数内でしか使えない
- 関数外で定義したものはどこでも使える<br>
*関数外で定義したものを関数内で更新した場合、再び関数外に出たときに更新された値になる？ならない？*

### クラス
- クラス：設計図
  - ```class クラス名{}``` 
- インスタンス：クラスから作成したオブジェクト
  - ```const インスタンス名 = new クラス名()```
- コンストラクタ：インスタンスを生成するときに必ず実行される処理
  - ```constructor(){}```
- メソッド：インスタンスの動作部分
  - ```メソッド名(){}```
- this : 当該インスタンスの持つ値やメソッドを使う場合につける
- 継承：既にあるクラスから新しくクラスを作成する
  - ```class 子クラス名 extends 親クラス名{}```
  - 子クラスで親クラスのメソッドをオーバーライドした場合、子クラスではオーバーライドしたメソッドが呼び出される
  - 親クラスのコンストラクタをオーバーライドする場合、子クラスのコンストラクタの1行目に```super()``` を記述する




### ファイルの分割-デフォルトエクスポート-
1つのファイルにつき、１つしかできない<br>
#### クラス単位の利用
1. ```export default クラス名;```でクラスをエクスポート
2. ```import クラス名 from "./ファイル名";```でクラスをインポート
   - ファイル名のところは相対パス、拡張子は不要

#### 定数単位の利用
1. ```export default 定数名;```でエクスポート
2. ```import 定数名 from "./ファイル名";```でインポート
   - exportした時の名前とimportするときの名前が異なっても問題ない（ひとつしか値がないため、自動で結び付けられる）

### ファイルの分割-名前付きエクスポート-
1. ```export {定数名1,定数名2,...};```でエクスポート
2. ```import {定数名1,定数名2,...} from "./ファイル名";```でインポート
   - 定数名はエクスポート時と同じにする

### パッケージの利用
```import 定数名 from "パッケージ名";```

#### chalkパッケージ
出力する文字の色を変える
```
import chalk from "chalk";
console.log(chalk.yellow("Hello"));
```

#### readline-syncパッケージ
コンソールから値を入力できる
  
```
import readlineSync from "readline-sync";
readlineSync.question("入力してください:");

\\整数を入力させる場合
readlineSync.questionInt("整数を入力してください:");
```

### npm
- Node.jsのパッケージ（予め用意された便利な機能）を管理するツール
  - Node.js : サーバーサイドのJavaScript実行環境<br>

- Node.jsをインストールすればnpmも自動でインストールされる<br>
- ```npm install パッケージ名```でパッケージをインストールできる

#### npm i と npm ci の違い
- npm i : package.jsonをもとにパッケージをインストール
  - 最新のパッケージをインストールするため、共同開発等では人によって環境がずれる危険性あり
- npm ci : package_lock.jsonをもとにパッケージをインストール
  - 動作確認済ver.のパッケージをインストールするため、人によってずれる心配がない
  - 検証環境の構築ではこっちを実行
